{%load static %}
<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Draggable Balls</title>
        <style>
                body { margin: 0; background-color: white; }
                input { width: 80px; margin-top: 5px; }
                #ui-panel { position: relative; z-index: 10; background: #f8f8f8; width: 800px; height: 35px; }
                #spawn-panel {position: relative; margin-top: -800px; margin-left: 800px; z-index: 2;}
                #spawnBtn {width: 80; height: 30px;}
                #canvas-main-wrapper { position: relative; width: 800px; height: 800px; }
                canvas { position: absolute; left: 0; top: 0; display: block; }
                #background { z-index: 0; background-color: black; }
                #foreground { z-index: 1; cursor: default; }
                #canvas-collision-example-wrapper {position: relative; margin-left: 1200px; margin-top: 90px;}
                #background2 {background-color:#696E71; width: 600px; height: 600px;}
        </style>
</head>
<body>
        <div>
                <div id="canvas-main-wrapper">
                        <canvas id="background"></canvas>
                        <canvas id="foreground"></canvas>
                </div>
                <div id="ui-panel">
                        <label>InitY(px): <input type="number" id="initY" value="765"></label>
                        <label>VelY(px/f): <input type="number" id="initV" value="0"></label>
                        <label>VelX(px/f): <input type="number" id="initVX" value="1"></label>
                        <button id="launchBtn">FIRE!</button>
                </div>
                <div id="spawn-panel">
                        <button id="spawnBtn">Spawn Button</button>
                </div>
        </div>
        <div id="canvas-collision-example-wrapper">
                <canvas id="background2"></canvas>
        </div>

        <script type="module">
                import { Ball } from "{% static 'js/ball.js' %}";

                const canvasW = 800;
                const canvasH = 800;
                const gravity = 0.1;
                const posDelta_checks_per_millisecond = 1;

                const bgCanvas = document.getElementById("background");
                const fgCanvas = document.getElementById("foreground");
                const bgCtx = bgCanvas.getContext("2d");
                const fgCtx = fgCanvas.getContext("2d");
                bgCanvas.width = fgCanvas.width = canvasW;
                bgCanvas.height = fgCanvas.height = canvasH;

                const input = {
                        mouseDown: false,
                        mouseUp: false,
                        mousePressed: false,
                        mouseX: 0,
                        mouseY: 0
                };

                const balls = [
                        //new Ball(fgCtx, 50, 100),
                        new Ball(fgCtx, 200, 300),
                        new Ball(fgCtx, 350, 200),
                        new Ball(fgCtx, 450, 200),
                        new Ball(fgCtx, 500, 200),
                ];
                window.balls = balls;
                balls[0].color = "rgb(250,0,0)"; balls[0].id = "Red";
                balls[1].color = "rgb(0,250,0)"; balls[1].id = "Green";
                balls[2].color = "rgb(0,0,250)"; balls[2].id = "Blue";
                balls[3].color = "rgb(250,250,0)"; balls[3].id = "Yellow";


                let G_fixList = [];
                window.G_fixList = G_fixList;
                
                let selectedBall = balls[0];

                function drawGrid() {
                        bgCtx.strokeStyle = "lightgray";
                        for (let i = 0; i < canvasH; i += 90) {
                                bgCtx.beginPath();
                                bgCtx.moveTo(0, i);
                                bgCtx.lineTo(canvasW, i);
                                bgCtx.stroke();
                        }
                }

                function updateState() {
                        for (const ball of balls) {
                                const otherBallsList = balls.filter(b => b !== ball);
                                ball.update(gravity, canvasW, canvasH, otherBallsList); //Collision checked
                                //Adding on the G_fixList >>>
                                if(ball.isOverlapped){
                                        AddToG_Fixlist(ball);                          
                                }
                                //<<< Adding on the G_fixList
                        }
                        if(G_fixList.length > 0) {console.log(`G_fixList.length: ${G_fixList.length}`)};
                        if(G_fixList.length > 0){
                                for(let i=0; i < G_fixList.length; i++){
                                        const ball = G_fixList[0];
                                        for(const otherBall of ball.fixList){
                                                console.log(`FixCollision Called from: ${ball.id}`);
                                                const collision_direction = ball.FindCollisionDir(otherBall); //collision direction for these two objects
                                                FixCollision(ball, otherBall, collision_direction);
                                                // let j = 0;
                                                // while(ball.isOverlapped && j<10){
                                                //         j++;
                                                //         ball.CheckCollision(otherBall);
                                                //         console.log(j);
                                                // }

                                        }
                                        G_fixList[0].isOverlapped = false;
                                        G_fixList.splice(0, 1,);//remove 1 item from index 0
                                }
                        }
                        G_fixList = [];
                }

                function FixCollision(selfball, otherball, collision_Dir){
                        //Pushes itself out of otherball
                        console.log(`FixCollision passed thru, with collision_Dir: ${collision_Dir}.`);
                        if (collision_Dir == "Top") {
                                selectedBall.velocityY = 0;
                                let yOverLap = (otherball.y + otherball.size) - selfball.y;
                                selfball.y += yOverLap;
                                if (selfball.velocityY == 0) {
                                        otherball.bottomCollided = true;
                                }
                        }
                        else if (collision_Dir == "Bottom") {
                                selectedBall.velocityY = 0;
                                let yOverLap = (selfball.y + selfball.size) - otherball.y;
                                selfball.y -= yOverLap;
                                if (otherball.velocityY == 0) {
                                        selfball.bottomCollided = true;
                                }

                        }
                        else if (collision_Dir == "Right") {
                                selectedBall.velocityX = 0;
                                let xOverLap = (selfball.x + selfball.size) - otherball.x;
                                selfball.x -= xOverLap;
                        }
                        else if (collision_Dir == "Left") {
                                selectedBall.velocityX = 0;
                                let xOverLap = (otherball.x + otherball.size) - selfball.x;
                                selfball.x += xOverLap;
                        }
                        selfball.isOverlapped = false;
                        otherball.isOverlapped = false;
                }

                //Adds to the list in priority order >>>
                //Priority order:
                //-Dragged object
                //-Moving object
                //Note: Non-moving objects are not added because they can't collide if they arn't moving
                function AddToG_Fixlist(insertBall){
                        console.log(`Added ball${insertBall.id} to G_fixList`);
                        if(!insertBall.isStatic){
                                G_fixList.push(insertBall);
                        }
                        else{console.log("Failed to insert ball to G_fixlist");}
                }

                function frame() {
                        // 各ボールの描画
                        updateState();
                        if (selectedBall?.isDragging && input.mousePressed) {
                                const otherBallsList = balls.filter(b => b !== selectedBall);
                                selectedBall.drag(input.mouseX, input.mouseY, posDelta_checks_per_millisecond, otherBallsList);
                        }
                        for (const ball of balls) {
                                ball.draw();   
                        }

                        // HUD 表示（選択中のみ）
                        if (selectedBall) {
                                drawHUD(input.mouseX, input.mouseY, selectedBall);
                        }

                        clearInputFlags();
                        requestAnimationFrame(frame);
                }

                function drawHUD(mouseX, mouseY, ball) {
                        const info = ball.getDebugInfo(mouseX, mouseY);
                        info.push(`G_FixList: ${G_fixList.length}`);
                        fgCtx.clearRect(590, 10, 240, info.length * 20 + 10);
                        ball.draw();
                        fgCtx.fillStyle = "rgba(255, 255, 255, 0.5)";
                        fgCtx.fillRect(590, 10, 240, info.length * 20 + 10);
                        fgCtx.font = "14px monospace";
                        fgCtx.fillStyle = "white";
                        //Inputting all of getDebugInfo into the gray HUD space
                        //Loops through each element and returns the data and the index
                        info.forEach((line, i) => {
                                fgCtx.fillText(line, 600, 30 + i * 20);}
                        );
                }

                function clearInputFlags() {
                        input.mouseDown = false;
                        input.mouseUp = false;
                }

                // イベント
                fgCanvas.addEventListener("mousedown", (e) => {
                        input.mouseDown = true;
                        input.mousePressed = true;
                        input.mouseX = e.clientX;
                        input.mouseY = e.clientY;

                        //Finds the ball that the mous is grabbing
                        for (let i = balls.length - 1; i >= 0; i--) {
                                if (balls[i].isMouseInside(input.mouseX, input.mouseY)) {
                                        selectedBall = balls[i]; //Once found stores in selectedBall
                                        //Reset velocity
                                        selectedBall.velocityX = 0; selectedBall.velocityY = 0;
                                        //Calculate the offset for the dragging sequence
                                        selectedBall.startDrag(input.mouseX, input.mouseY);
                                        //Finishing touches
                                        fgCanvas.style.cursor = "grabbing";
                                        break;
                                }
                        }
                });

                fgCanvas.addEventListener("mouseup", (e) => {
                        input.mouseUp = true;
                        input.mousePressed = false;
                        input.mouseX = e.clientX;
                        input.mouseY = e.clientY;
                        //Dragging sequence
                        if (selectedBall?.isDragging) {
                                selectedBall.endDrag(input.mouseX, input.mouseY);
                                fgCanvas.style.cursor = "default";
                        }
                });

                fgCanvas.addEventListener("mousemove", (e) => {
                        input.mouseX = e.clientX;
                        input.mouseY = e.clientY;
                        
                });

                document.getElementById("launchBtn").addEventListener("click", () => {
                        if (!selectedBall) return;
                        const initY = parseFloat(document.getElementById("initY").value);
                        const initV = parseFloat(document.getElementById("initV").value);
                        const initVX = parseFloat(document.getElementById("initVX").value);

                        if (!isNaN(initY)) selectedBall.y = initY;
                        if (!isNaN(initV)) selectedBall.velocityY = initV;
                        if (!isNaN(initVX)) selectedBall.velocityX = initVX;

                        selectedBall.isDragging = false;
                        selectedBall.isFalling = true;
                        selectedBall.needsRedraw = true;
                        fgCanvas.style.cursor = "default";
                });

                document.getElementById("spawnBtn").addEventListener("click", () =>{
                        balls.push(new Ball(fgCtx, 0, 0));
                        selectedBall = balls[balls.length - 1];
                })

                drawGrid();
                requestAnimationFrame(frame);
        </script>
</body>
</html>